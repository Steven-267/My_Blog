"use strict";(self.webpackChunkblog_road=self.webpackChunkblog_road||[]).push([[9433],{6262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,t]of s)a[i]=t;return a}},9526:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>e,data:()=>h});var t=a(641);const l=[(0,t.Fv)('<h1 id="java-一篇文章带你玩转static关键字" tabindex="-1"><a class="header-anchor" href="#java-一篇文章带你玩转static关键字"><span>Java | 一篇文章带你玩转Static关键字</span></a></h1><h2 id="static" tabindex="-1"><a class="header-anchor" href="#static"><span>Static</span></a></h2><h3 id="作用" tabindex="-1"><a class="header-anchor" href="#作用"><span>作用</span></a></h3><p>Static是Java的一个关键字，用于声明静态成员或者方法。Static的作用是为类的成员（字段和方法）分配一个共享的内存空间，而不是为每一个类的对象分别进行内存分配。（Ps：但我们多个对象想操控同一个变量时，就可以在类中定义一个静态变量）</p><h3 id="知识补充" tabindex="-1"><a class="header-anchor" href="#知识补充"><span>知识补充</span></a></h3><h4 id="类加载-class-loading" tabindex="-1"><a class="header-anchor" href="#类加载-class-loading"><span><strong>类加载 (Class Loading)</strong>:</span></a></h4><ul><li>类加载是指将类的字节码文件加载到 JVM 中的过程。</li><li>当你使用类时，JVM 需要将类加载到内存中，以便可以创建对象和执行类的方法。</li><li>类加载发生在对象创建之前，因为在创建对象之前，必须首先加载类。</li></ul><h3 id="静态变量-static-variables" tabindex="-1"><a class="header-anchor" href="#静态变量-static-variables"><span>静态变量（Static Variables）</span></a></h3><ul><li>static<strong>只</strong>与类相关，而不是和类对象相关联</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyClass</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> count </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> // 静态变量，所有对象共享 </span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>它们在<strong>类加载</strong>时被分配内存，并且只有一份共享的内存副本。</p></li><li><p>静态成员变量在整个应用程序的生命周期内存在，直到程序终止。它们通常用于存储全局数据、配置信息或共享状态。</p></li><li><p>这些静态成员变量的内存分配在类加载时，而不是在对象实例化时。</p></li></ul><h3 id="静态方法-static-methods" tabindex="-1"><a class="header-anchor" href="#静态方法-static-methods"><span>静态方法（<strong>Static Methods</strong>）</span></a></h3><ul><li>静态方法是和类相关联，而不是和类对象关联</li><li>静态方法可以直接通过类名进行调用，无需创建对象</li><li>通常用于实用工具方法或工厂方法</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MathUtils</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> b;    </span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="静态代码块-static-initialization-blocks" tabindex="-1"><a class="header-anchor" href="#静态代码块-static-initialization-blocks"><span><strong>静态代码块 (Static Initialization Blocks)</strong></span></a></h3><ul><li>静态代码块是在类加载时执行的代码块，用于初始化静态变量或执行其他静态操作。</li><li>通常用于执行一次性的初始化操作。</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> AppConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // 初始化配置参数</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // 从文件或数据库加载配置    </span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } </span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="静态内部类-static-inner-classes" tabindex="-1"><a class="header-anchor" href="#静态内部类-static-inner-classes"><span><strong>静态内部类 (Static Inner Classes)</strong></span></a></h3><ul><li>静态内部类是定义在类内部的类，但被声明为静态。</li><li>静态内部类不依赖于外部类的实例，可以直接创建实例。</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> OuterClass</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> InnerClass</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // 静态内部类    </span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="静态导入-static-imports" tabindex="-1"><a class="header-anchor" href="#静态导入-static-imports"><span><strong>静态导入 (Static Imports)</strong></span></a></h3><ul><li>静态导入允许在不使用类名前缀的情况下使用静态方法和常量。</li><li>用于简化代码，提高可读性。</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> java.lang.Math.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> // 静态导入 Math 类的所有静态成员</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MathOperations</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        double</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> result</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> sqrt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">16.0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// 直接使用 sqrt 方法，而不需要 Math.sqrt</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="静态方法可以通过实现类名调用的底层原理" tabindex="-1"><a class="header-anchor" href="#静态方法可以通过实现类名调用的底层原理"><span>静态方法可以通过实现类名调用的底层原理</span></a></h3><p>之前在没有深入了解，我一直以为是通过反射来实现通过类名调用静态方法，但这并不涉及底层的反射机制。实际上，静态方法的访问和调用是通过**编译时绑定（静态绑定）而不是运行时绑定（反射）**来完成的。这是因为静态方法在编译时就已经绑定到类，编译器可以确定要调用哪个方法，不需要在运行时查找方法。</p><p>反射机制涉及在运行时动态地获取类的信息，创建类的实例，访问或调用对象的字段、方法和构造函数。这与静态方法的直接访问方式不同。反射是一种强大的机制，但通常涉及到更高的复杂性和性能开销，因此在不需要它的情况下，应该尽量避免使用反射。</p><p>要强调的是，静态方法的直接访问是一种静态绑定的过程，而反射是一种动态绑定的过程，它们用于不同的目的和场景。</p><h3 id="既然可以直接通过类名调用-那为什么还要实例对象" tabindex="-1"><a class="header-anchor" href="#既然可以直接通过类名调用-那为什么还要实例对象"><span>既然可以直接通过类名调用，那为什么还要实例对象？</span></a></h3><ol><li><p><strong>对象状态</strong>: 静态方法<strong>不可以访问对象的状态</strong>（实例变量），因为它们不依赖于特定的对象。如果方法需要访问对象的状态来执行操作，那么它应该是实例方法。</p></li><li><p><strong>继承和多态</strong>: 静态方法<strong>不支持多态</strong>，因为它们与类相关而不是对象相关。实例方法允许子类覆盖（重写）父类的方法，从而支持多态。</p></li><li><p><strong>可维护性和扩展性</strong>: 静态方法不依赖于对象，这可能会导致<strong>较弱的封装和较低的可维护性</strong>。实例方法通常更容易维护和扩展，因为它们封装了对象的行为和状态。</p></li><li><p><strong>测试和模拟</strong>: 实例方法通常更容易进行单元测试和模拟，因为它们可以使用模拟对象代替实际对象。静态方法通常不支持这种模拟。</p></li><li><p><strong>面向对象设计原则</strong>: 静态方法通常破坏了面向对象编程的一些原则，如封装、多态和继承。选择何时使用静态方法和何时使用实例方法应该考虑这些原则。</p></li></ol><p>尽管静态方法在某些情况下非常有用，但它们应该<strong>谨慎</strong>使用，并根据方法的用途和行为来选择。在大多数情况下，实例方法更符合面向对象的编程原则，并更具灵活性和可维护性。静态方法通常用于实用工具方法、工厂方法和一些全局操作，但不应滥用。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><h3 id="static关键字的核心特点" tabindex="-1"><a class="header-anchor" href="#static关键字的核心特点"><span>Static关键字的核心特点</span></a></h3><ol><li><strong>内存共享</strong>：静态成员在所有对象间共享同一内存空间</li><li><strong>类级别</strong>：属于类而非对象，可通过类名直接访问</li><li><strong>生命周期</strong>：随类加载而创建，随程序结束而销毁</li><li><strong>编译时绑定</strong>：静态方法在编译时确定，不支持多态</li></ol><h3 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景</span></a></h3><p><strong>适合使用static的场景：</strong></p><ul><li>工具类方法（如Math.max()）</li><li>常量定义（如final static常量）</li><li>计数器或共享状态</li><li>工厂方法</li><li>一次性初始化操作</li></ul><p><strong>避免使用static的场景：</strong></p><ul><li>需要多态的方法</li><li>需要访问对象状态的方法</li><li>需要单元测试模拟的方法</li><li>过于频繁的状态变更</li></ul><h3 id="最佳实践" tabindex="-1"><a class="header-anchor" href="#最佳实践"><span>最佳实践</span></a></h3><ol><li><strong>明确用途</strong>：只在确实需要类级别共享时使用</li><li><strong>避免滥用</strong>：不要为了方便而随意添加static</li><li><strong>考虑线程安全</strong>：静态变量在多线程环境下需要考虑同步</li><li><strong>遵循设计原则</strong>：保持良好的面向对象设计</li></ol>',40)],n={},e=(0,a(6262).A)(n,[["render",function(i,s){return(0,t.uX)(),(0,t.CE)("div",null,l)}]]),h=JSON.parse('{"path":"/tech/%E6%95%99%E7%A8%8B/Java%20Static%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90.html","title":"Java Static关键字完全解析","lang":"zh-CN","frontmatter":{"title":"Java Static关键字完全解析","date":"2023-10-29T00:00:00.000Z","category":["技术教程"],"tag":["Java","static","面向对象","Java基础","内存管理"],"author":"Steven267","isOriginal":true,"description":"Java | 一篇文章带你玩转Static关键字 Static 作用 Static是Java的一个关键字，用于声明静态成员或者方法。Static的作用是为类的成员（字段和方法）分配一个共享的内存空间，而不是为每一个类的对象分别进行内存分配。（Ps：但我们多个对象想操控同一个变量时，就可以在类中定义一个静态变量） 知识补充 类加载 (Class Load...","head":[["meta",{"property":"og:url","content":"https://steven-267.github.io/My_Blog/tech/%E6%95%99%E7%A8%8B/Java%20Static%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90.html"}],["meta",{"property":"og:site_name","content":"Steven267的技术博客"}],["meta",{"property":"og:title","content":"Java Static关键字完全解析"}],["meta",{"property":"og:description","content":"Java | 一篇文章带你玩转Static关键字 Static 作用 Static是Java的一个关键字，用于声明静态成员或者方法。Static的作用是为类的成员（字段和方法）分配一个共享的内存空间，而不是为每一个类的对象分别进行内存分配。（Ps：但我们多个对象想操控同一个变量时，就可以在类中定义一个静态变量） 知识补充 类加载 (Class Load..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-23T12:03:27.000Z"}],["meta",{"property":"article:author","content":"Steven267"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"static"}],["meta",{"property":"article:tag","content":"面向对象"}],["meta",{"property":"article:tag","content":"Java基础"}],["meta",{"property":"article:tag","content":"内存管理"}],["meta",{"property":"article:published_time","content":"2023-10-29T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-23T12:03:27.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java Static关键字完全解析\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-10-29T00:00:00.000Z\\",\\"dateModified\\":\\"2025-07-23T12:03:27.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Steven267\\"}]}"]]},"headers":[{"level":2,"title":"Static","slug":"static","link":"#static","children":[{"level":3,"title":"作用","slug":"作用","link":"#作用","children":[]},{"level":3,"title":"知识补充","slug":"知识补充","link":"#知识补充","children":[]},{"level":3,"title":"静态变量（Static Variables）","slug":"静态变量-static-variables","link":"#静态变量-static-variables","children":[]},{"level":3,"title":"静态方法（Static Methods）","slug":"静态方法-static-methods","link":"#静态方法-static-methods","children":[]},{"level":3,"title":"静态代码块 (Static Initialization Blocks)","slug":"静态代码块-static-initialization-blocks","link":"#静态代码块-static-initialization-blocks","children":[]},{"level":3,"title":"静态内部类 (Static Inner Classes)","slug":"静态内部类-static-inner-classes","link":"#静态内部类-static-inner-classes","children":[]},{"level":3,"title":"静态导入 (Static Imports)","slug":"静态导入-static-imports","link":"#静态导入-static-imports","children":[]},{"level":3,"title":"静态方法可以通过实现类名调用的底层原理","slug":"静态方法可以通过实现类名调用的底层原理","link":"#静态方法可以通过实现类名调用的底层原理","children":[]},{"level":3,"title":"既然可以直接通过类名调用，那为什么还要实例对象？","slug":"既然可以直接通过类名调用-那为什么还要实例对象","link":"#既然可以直接通过类名调用-那为什么还要实例对象","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[{"level":3,"title":"Static关键字的核心特点","slug":"static关键字的核心特点","link":"#static关键字的核心特点","children":[]},{"level":3,"title":"使用场景","slug":"使用场景","link":"#使用场景","children":[]},{"level":3,"title":"最佳实践","slug":"最佳实践","link":"#最佳实践","children":[]}]}],"git":{"createdTime":1753272207000,"updatedTime":1753272207000},"readingTime":{"minutes":5.65,"words":1695},"filePathRelative":"tech/教程/Java Static关键字完全解析.md","localizedDate":"2023年10月29日","excerpt":"\\n<h2>Static</h2>\\n<h3>作用</h3>\\n<p>Static是Java的一个关键字，用于声明静态成员或者方法。Static的作用是为类的成员（字段和方法）分配一个共享的内存空间，而不是为每一个类的对象分别进行内存分配。（Ps：但我们多个对象想操控同一个变量时，就可以在类中定义一个静态变量）</p>\\n<h3>知识补充</h3>\\n<h4><strong>类加载 (Class Loading)</strong>:</h4>\\n<ul>\\n<li>类加载是指将类的字节码文件加载到 JVM 中的过程。</li>\\n<li>当你使用类时，JVM 需要将类加载到内存中，以便可以创建对象和执行类的方法。</li>\\n<li>类加载发生在对象创建之前，因为在创建对象之前，必须首先加载类。</li>\\n</ul>","autoDesc":true}')}}]);