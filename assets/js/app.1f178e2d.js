"use strict";(self.webpackChunkblog_road=self.webpackChunkblog_road||[]).push([[3524],{1709:(e,n,s)=>{s.d(n,{l:()=>a});const a={category:{"/":{path:"/category/",map:{思考:{path:"/category/%E6%80%9D%E8%80%83/",indexes:[0]},后端:{path:"/category/%E5%90%8E%E7%AB%AF/",indexes:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36]},算法:{path:"/category/%E7%AE%97%E6%B3%95/",indexes:[37]},技术教程:{path:"/category/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/",indexes:[38,39,40]}}}},tag:{"/":{path:"/tag/",map:{思考:{path:"/tag/%E6%80%9D%E8%80%83/",indexes:[0]},职场感悟:{path:"/tag/%E8%81%8C%E5%9C%BA%E6%84%9F%E6%82%9F/",indexes:[0]},技术人生:{path:"/tag/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/",indexes:[0]},工作与生活:{path:"/tag/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E7%94%9F%E6%B4%BB/",indexes:[0]},双指针:{path:"/tag/%E5%8F%8C%E6%8C%87%E9%92%88/",indexes:[11,20,33,35]},leecode:{path:"/tag/leecode/",indexes:[10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36]},哈希:{path:"/tag/%E5%93%88%E5%B8%8C/",indexes:[10,24,26]},子串:{path:"/tag/%E5%AD%90%E4%B8%B2/",indexes:[14,25,30]},前缀和:{path:"/tag/%E5%89%8D%E7%BC%80%E5%92%8C/",indexes:[14]},滑动窗口:{path:"/tag/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/",indexes:[22,25,29,30]},数组:{path:"/tag/%E6%95%B0%E7%BB%84/",indexes:[12,16,23,27,28]},矩阵:{path:"/tag/%E7%9F%A9%E9%98%B5/",indexes:[13,18,31,34]},链表:{path:"/tag/%E9%93%BE%E8%A1%A8/",indexes:[15,17,19,21,37,32,36]},快慢指针:{path:"/tag/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/",indexes:[15,17,19,32]},leetcode:{path:"/tag/leetcode/",indexes:[37]},Java:{path:"/tag/java/",indexes:[38,1,2,3,4,5,6,7,8,9,39,40]},面试:{path:"/tag/%E9%9D%A2%E8%AF%95/",indexes:[1,2,3,4,5,6,7,8,9]},场景:{path:"/tag/%E5%9C%BA%E6%99%AF/",indexes:[1,2,3,4,5,6,7,8,9]},static:{path:"/tag/static/",indexes:[39]},面向对象:{path:"/tag/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/",indexes:[39]},Java基础:{path:"/tag/java%E5%9F%BA%E7%A1%80/",indexes:[39,40]},内存管理:{path:"/tag/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/",indexes:[39]},环境配置:{path:"/tag/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/",indexes:[40]},开发环境:{path:"/tag/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/",indexes:[40]},Maven:{path:"/tag/maven/",indexes:[40]},exe4j:{path:"/tag/exe4j/",indexes:[38]},"inno setup":{path:"/tag/inno-setup/",indexes:[38]},程序打包:{path:"/tag/%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/",indexes:[38]},部署:{path:"/tag/%E9%83%A8%E7%BD%B2/",indexes:[38]}}}}}},4776:(e,n,s)=>{s.d(n,{M:()=>a});const a=["/tech/%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%A4%96%EF%BC%8C%E6%88%91%E4%BB%AC%E8%AF%A5%E6%80%9D%E8%80%83%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F.html","/tech/%E5%9C%BA%E6%99%AF/mq%E6%B6%88%E8%B4%B9%E6%96%B9%E5%BC%8F.html","/tech/%E5%9C%BA%E6%99%AF/%E7%9F%AD%E9%93%BE%E6%8E%A5.html","/tech/%E5%9C%BA%E6%99%AF/Rpc.html","/tech/%E5%9C%BA%E6%99%AF/%E7%A7%92%E6%9D%80.html","/tech/%E5%9C%BA%E6%99%AF/mq.html","/tech/%E5%9C%BA%E6%99%AF/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html","/tech/%E5%9C%BA%E6%99%AF/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%95%E4%BE%8B.html","/tech/%E5%9C%BA%E6%99%AF/%E5%B9%B6%E5%8F%91%E6%B5%81%E7%BB%9F%E8%AE%A1.html","/tech/%E5%9C%BA%E6%99%AF/%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8Cdfa%E7%AE%97%E6%B3%95%E8%84%B1%E6%95%8F.html","/leetcode/%E5%93%88%E5%B8%8C/%E4%BF%A9%E6%95%B0%E4%B9%8B%E5%92%8C.html","/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html","/leetcode/%E6%95%B0%E7%BB%84/%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0.html","/leetcode/%E7%9F%A9%E9%98%B5/%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5.html","/leetcode/%E5%AD%90%E4%B8%B2/%E5%92%8C%E4%B8%BA%20K%20%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html","/leetcode/%E9%93%BE%E8%A1%A8/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8.html","/leetcode/%E6%95%B0%E7%BB%84/%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84.html","/leetcode/%E9%93%BE%E8%A1%A8/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.html","/leetcode/%E7%9F%A9%E9%98%B5/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5.html","/leetcode/%E9%93%BE%E8%A1%A8/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II.html","/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/%E7%A7%BB%E5%8A%A8%E9%9B%B6.html","/leetcode/%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html","/leetcode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.html","/leetcode/%E6%95%B0%E7%BB%84/%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF.html","/leetcode/%E5%93%88%E5%B8%8C/%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84.html","/leetcode/%E5%AD%90%E4%B8%B2/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2.html","/leetcode/%E5%93%88%E5%B8%8C/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97.html","/leetcode/%E6%95%B0%E7%BB%84/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C.html","/leetcode/%E6%95%B0%E7%BB%84/%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html","/leetcode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html","/leetcode/%E5%AD%90%E4%B8%B2/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html","/leetcode/%E7%9F%A9%E9%98%B5/%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6.html","/leetcode/%E9%93%BE%E8%A1%A8/%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.html","/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/%E6%8E%A5%E9%9B%A8%E6%B0%B4.html","/leetcode/%E7%9F%A9%E9%98%B5/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F.html","/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8.html","/leetcode/%E9%93%BE%E8%A1%A8/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.html","/leetcode/%E9%93%BE%E8%A1%A8/%E4%BF%A9%E6%95%B0%E7%9B%B8%E5%8A%A0.html","/tech/%E6%95%99%E7%A8%8B/Java%E7%A8%8B%E5%BA%8F%E8%BD%ACexe%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B.html","/tech/%E6%95%99%E7%A8%8B/Java%20Static%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90.html","/tech/%E6%95%99%E7%A8%8B/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%20-%20PATH%E4%B8%8ECLASSPATH.html"]},3781:(e,n,s)=>{s.d(n,{U:()=>a});const a={article:{"/":{path:"/article/",indexes:[0,38,1,2,3,4,5,6,7,8,9,10,11,39,40,12,13,14,15,16,17,18,19,20,21,22,23,37,24,25,26,27,28,29,30,31,32,33,34,35,36]}},star:{"/":{path:"/star/",indexes:[0]}},timeline:{"/":{path:"/timeline/",indexes:[0,1,2,3,4,38,5,6,7,8,9,10,11,39,40,12,13,14,15,16,17,18,19,20,21,22,23,37,24,25,26,27,28,29,30,31,32,33,34,35,36]}}}},3600:(e,n,s)=>{s.d(n,{B:()=>P});var a={};s.r(a);var t={};s.r(t);var i={};s.r(i),s.d(i,{default:()=>g});var l={};s.r(l),s.d(l,{default:()=>D});var d={};s.r(d),s.d(d,{default:()=>S});var r=s(8278),o=s(3812),c=s(3073),h=s(9403),p=s(596),E=s(8831);const g=(0,r.re)({enhance:({app:e})=>{(0,o.L4)("FontIcon")||e.component("FontIcon",h.A),(0,o.L4)("Badge")||e.component("Badge",p.A),(0,o.L4)("VPCard")||e.component("VPCard",E.A)},setup:()=>{(0,c.r9V)("https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/js/brands.min.js",(()=>{}),{attrs:{"data-auto-replace-svg":"nest"}}),(0,c.r9V)("https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/js/solid.min.js",(()=>{}),{attrs:{"data-auto-replace-svg":"nest"}}),(0,c.r9V)("https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/js/fontawesome.min.js",(()=>{}),{attrs:{"data-auto-replace-svg":"nest"}})},rootComponents:[]});var A=s(6358),m=s(9588),B=s(355),u=s(1599),b=s(5496),v=s(457),k=s(7152),F=s(5214),C=s(1219),y=s(3027),x=s(2763);const D=(0,r.re)({enhance:({app:e})=>{e.component("CodeTabs",k.A),(0,o.L4)("CodeGroup",e)||e.component("CodeGroup",F.lF),(0,o.L4)("CodeGroupItem",e)||e.component("CodeGroupItem",F.E7),e.component("CodeDemo",C.A),e.component("MdDemo",y.A)},setup:()=>{(0,x.p)()}});var f=s(3004),w=s(783),I=s(8465),q=s(641),J=s(8030),j=s(9920);(0,I.M_)((e=>{const n=e.t,s=!1!==e.I,a=e.i;return s?{title:n,content:a?()=>[(0,q.h)(w.GB,{icon:a}),n]:null,order:e.O,index:e.I}:null}));const S=(0,r.re)({enhance:({app:e,router:n})=>{const{scrollBehavior:s}=n.options;n.options.scrollBehavior=async(...e)=>(await w.lE.wait(),s(...e)),(0,w.fk)(e),e.component("HopeIcon",w.GB),e.component("BloggerInfo",J.tI),e.component("SocialMedias",J.rS),e.component("GlobalEncrypt",j.J),e.component("LocalEncrypt",j.n)},setup:()=>{(0,w.PV)(),(0,w.i$)(),(0,J.su)()},layouts:{Layout:w.PE,NotFound:w.Mk,BlogCategory:J.Pn,BlogHome:J.qX,BlogType:J.z7,Timeline:J.Kf}}),P=[a,t,i,A,m,B,u,b,v,l,f,d].map((e=>e.default)).filter(Boolean)},8164:(e,n,s)=>{s.d(n,{J:()=>t,c:()=>a});const a=JSON.parse("{}"),t=Object.fromEntries([["/",{loader:()=>s.e(4470).then(s.bind(s,4298)),meta:{t:"博客主页",i:"home"}}],["/tech/%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%A4%96%EF%BC%8C%E6%88%91%E4%BB%AC%E8%AF%A5%E6%80%9D%E8%80%83%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F.html",{loader:()=>s.e(933).then(s.bind(s,5223)),meta:{a:"Steven267",d:17532288e5,l:"2025年7月23日",c:["思考"],g:["思考","职场感悟","技术人生","工作与生活"],u:100,o:!0,e:'<h2>技术之外，我们该思考些什么？</h2>\n<p>可能很多人第一想法是钱，但我想聊一聊关于钱以外，我自己的一些看法。</p>\n<p>从大学开始，生活似乎就和技术紧密相连：学习一个又一个技术栈，寻找一份又一份实习，编写一行又一行代码，理解一个又一个业务逻辑。日复一日。</p>\n<p>实习的某一天晚上，在工位上抬头往窗外望，已是漆黑一片。停下敲键盘的手，我不禁想：<br>\n<strong>"这一年的实习经历，除了不断的学习技术，我们是不是应该思考技术之外的东西？"</strong></p>\n<p>技术无疑是重要的，它驱动着我们前进。但仅有技术，似乎并不足够支撑起<mark>完整的职业旅程，甚至生活本身</mark>。</p>',r:{minutes:4.55,words:1365},t:"🌟 技术之外，我们该思考些什么？",y:"a"}}],["/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html",{loader:()=>s.e(6900).then(s.bind(s,312)),meta:{d:16988832e5,l:"2023年11月2日",c:["后端"],g:["双指针","leecode"],e:"\n<h3><strong>题目：三数之和</strong></h3>\n<p><strong>描述：</strong></p>\n<p>给定一个整数数组 <code>nums</code>，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足以下条件：</p>\n<ul>\n<li><code>i != j</code>、<code>i != k</code> 且 <code>j != k</code>。</li>\n<li><code>nums[i] + nums[j] + nums[k] == 0</code>。</li>\n</ul>\n<p>请返回所有和为 <code>0</code> 且不重复的三元组。</p>",r:{minutes:2.28,words:685},t:"三数之和",i:"pen-to-square",y:"a"}}],["/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/%E6%8E%A5%E9%9B%A8%E6%B0%B4.html",{loader:()=>s.e(5663).then(s.bind(s,1210)),meta:{d:16676064e5,l:"2022年11月5日",c:["后端"],g:["双指针","leecode"],e:'\n<h3><strong>题目：接雨水</strong></h3>\n<p><strong>描述：</strong></p>\n<p>给定 <code>n</code> 个非负整数表示每个宽度为 1 的柱子的高度图，计算它们能接住多少雨水。</p>\n<hr>\n<h3><strong>示例：</strong></h3>\n<p><strong>示例 1:</strong></p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span></span>\n<span class="line"><span>输出：6</span></span>\n<span class="line"><span>解释：在这种情况下，计算能接的雨水总量为 6。</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:5.93,words:1780},t:"接雨水",i:"pen-to-square",y:"a"}}],["/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8.html",{loader:()=>s.e(410).then(s.bind(s,7708)),meta:{d:16644096e5,l:"2022年9月29日",c:["后端"],g:["双指针","leecode"],e:"\n<h3><strong>题目：盛最多水的容器</strong></h3>\n<p><strong>描述：</strong></p>\n<p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code>，数组中的每个元素 <code>height[i]</code> 表示第 <code>i</code> 条垂线的高度。第 <code>i</code> 条垂线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code>。</p>\n<p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>\n",r:{minutes:2.39,words:717},t:"盛最多水的容器",i:"pen-to-square",y:"a"}}],["/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/%E7%A7%BB%E5%8A%A8%E9%9B%B6.html",{loader:()=>s.e(4499).then(s.bind(s,1565)),meta:{d:16868736e5,l:"2023年6月16日",c:["后端"],g:["双指针","leecode"],e:'\n<h3><strong>题目：移动零</strong></h3>\n<p><strong>描述：</strong></p>\n<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>\n<p><strong>要求：</strong></p>\n<ul>\n<li>必须在不复制数组的情况下原地对数组进行操作。</li>\n</ul>\n<hr>\n<h3><strong>示例：</strong></h3>\n<p><strong>示例 1:</strong></p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入: nums = [0, 1, 0, 3, 12]</span></span>\n<span class="line"><span>输出: [1, 3, 12, 0, 0]</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:1.91,words:574},t:"移动零",i:"pen-to-square",y:"a"}}],["/leetcode/%E5%93%88%E5%B8%8C/%E4%BF%A9%E6%95%B0%E4%B9%8B%E5%92%8C.html",{loader:()=>s.e(3139).then(s.bind(s,5106)),meta:{d:17006976e5,l:"2023年11月23日",c:["后端"],g:["哈希","leecode"],e:"\n<h3><strong>题目：两数之和</strong></h3>\n<p><strong>描述：</strong></p>\n<p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <code>target</code> 的两个数，并返回它们的数组下标。</p>\n<p>你可以假设每种输入只会有 <strong>一个解</strong>，并且同样的元素不能被重复利用。</p>\n<p><strong>你可以按任意顺序返回答案。</strong></p>\n<hr>\n<h3><strong>示例：</strong></h3>",r:{minutes:2.3,words:690},t:"两数之和",i:"pen-to-square",y:"a"}}],["/leetcode/%E5%93%88%E5%B8%8C/%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84.html",{loader:()=>s.e(507).then(s.bind(s,7207)),meta:{d:16797888e5,l:"2023年3月26日",c:["后端"],g:["哈希","leecode"],e:'\n<h3><strong>题目：字母异位词分组</strong></h3>\n<p><strong>描述：</strong></p>\n<p>给定一个字符串数组 <code>strs</code>，将字母异位词组合在一起。字母异位词是由重新排列源单词的所有字母得到的一个新单词。</p>\n<p><strong>示例：</strong></p>\n<p><strong>示例 1:</strong></p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]</span></span>\n<span class="line"><span>输出: [["eat", "tea", "ate"], ["tan", "nat"], ["bat"]]</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:2.45,words:735},t:"字母异位词分组",i:"pen-to-square",y:"a"}}],["/leetcode/%E5%93%88%E5%B8%8C/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97.html",{loader:()=>s.e(1623).then(s.bind(s,2470)),meta:{d:16768512e5,l:"2023年2月20日",c:["后端"],g:["哈希","leecode"],e:'\n<h3><strong>题目：最长连续序列</strong></h3>\n<p><strong>描述：</strong></p>\n<p>给定一个未排序的整数数组 <code>nums</code>，找出数字连续的最长序列的长度。<strong>不要求序列元素在原数组中连续</strong>。</p>\n<hr>\n<h3><strong>示例：</strong></h3>\n<p><strong>示例 1:</strong></p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入: nums = [100, 4, 200, 1, 3, 2]</span></span>\n<span class="line"><span>输出: 4</span></span>\n<span class="line"><span>解释: 最长连续序列是 [1, 2, 3, 4]，长度为 4。</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:2.23,words:669},t:"最长连续序列",i:"pen-to-square",y:"a"}}],["/leetcode/%E5%AD%90%E4%B8%B2/%E5%92%8C%E4%B8%BA%20K%20%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html",{loader:()=>s.e(4882).then(s.bind(s,7258)),meta:{d:16955136e5,l:"2023年9月24日",c:["后端"],g:["子串","前缀和","leecode"],e:"\n<hr>\n<h3><strong>问题理解</strong></h3>\n<p>我们需要找到 <strong>连续子数组</strong> 的和等于给定值 <code>k</code> 的个数。</p>\n<p><strong>定义子数组</strong>：</p>\n<ul>\n<li>子数组是数组中任意连续的一段。</li>\n<li>比如，对于数组 <code>[1, 2, 3, 4]</code>，长度为 3 的子数组有 <code>[1, 2, 3]</code> 和 <code>[2, 3, 4]</code>。</li>\n</ul>\n<hr>\n<h3><strong>解题核心：前缀和 + 哈希表</strong></h3>",r:{minutes:3.7,words:1110},t:"和为 K 的子数组",i:"pen-to-square",y:"a"}}],["/leetcode/%E5%AD%90%E4%B8%B2/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2.html",{loader:()=>s.e(9020).then(s.bind(s,14)),meta:{d:16781472e5,l:"2023年3月7日",c:["后端"],g:["子串","滑动窗口","leecode"],e:'\n<h3><strong>题目：最小覆盖子串</strong></h3>\n<h4><strong>描述：</strong></h4>\n<p>给定两个字符串 <code>s</code> 和 <code>t</code>，返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>""</code>。</p>\n<hr>\n<h3><strong>示例：</strong></h3>\n<p><strong>示例 1:</strong></p>\n<div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入: s = "ADOBECODEBANC", t = "ABC"</span></span>\n<span class="line"><span>输出: "BANC"</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:4.14,words:1241},t:"最小覆盖子串",i:"pen-to-square",y:"a"}}],["/leetcode/%E5%AD%90%E4%B8%B2/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html",{loader:()=>s.e(7333).then(s.bind(s,8249)),meta:{d:167184e7,l:"2022年12月24日",c:["后端"],g:["子串","滑动窗口","leecode"],e:'\n<h3><strong>题目：滑动窗口最大值</strong></h3>\n<p><strong>描述：</strong></p>\n<p>给定一个整数数组 <code>nums</code>，和一个整数 <code>k</code>，表示滑动窗口的大小。滑动窗口从数组的最左侧向最右侧移动，每次移动一位。</p>\n<p>要求：返回每次滑动窗口中的最大值。</p>\n<hr>\n<h3><strong>示例：</strong></h3>\n<p><strong>示例 1:</strong></p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入: nums = [1,3,-1,-3,5,3,6,7], k = 3</span></span>\n<span class="line"><span>输出: [3,3,5,5,6,7]</span></span>\n<span class="line"><span>解释: </span></span>\n<span class="line"><span>滑动窗口的位置                最大值</span></span>\n<span class="line"><span>---------------               -----</span></span>\n<span class="line"><span>[1  3  -1] -3  5  3  6  7       3</span></span>\n<span class="line"><span> 1 [3  -1  -3] 5  3  6  7       3</span></span>\n<span class="line"><span> 1  3 [-1  -3   5] 3  6  7       5</span></span>\n<span class="line"><span> 1  3  -1 [-3   5   3] 6  7       5</span></span>\n<span class="line"><span> 1  3  -1  -3 [5   3   6] 7       6</span></span>\n<span class="line"><span> 1  3  -1  -3   5 [3   6   7]      7</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:4.84,words:1452},t:"滑动窗口最大值",i:"pen-to-square",y:"a"}}],["/leetcode/%E6%95%B0%E7%BB%84/%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html",{loader:()=>s.e(5013).then(s.bind(s,1889)),meta:{d:16740864e5,l:"2023年1月19日",c:["后端"],g:["数组","leecode"],e:'\n<h3><strong>题目：合并区间</strong></h3>\n<h4><strong>描述：</strong></h4>\n<p>给定一个区间集合 <code>intervals</code>，每个区间用 <code>[starti, endi]</code> 表示。需要合并所有 <strong>重叠</strong> 的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p>\n<hr>\n<h3><strong>示例：</strong></h3>\n<p><strong>示例 1:</strong></p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入: intervals = [[1,3],[2,6],[8,10],[15,18]]</span></span>\n<span class="line"><span>输出: [[1,6],[8,10],[15,18]]</span></span>\n<span class="line"><span>解释: 区间 [1,3] 和 [2,6] 重叠, 合并为 [1,6].</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:3.42,words:1025},t:"合并区间",i:"pen-to-square",y:"a"}}],["/leetcode/%E6%95%B0%E7%BB%84/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C.html",{loader:()=>s.e(9336).then(s.bind(s,3049)),meta:{d:16758144e5,l:"2023年2月8日",c:["后端"],g:["数组","leecode"],e:'\n<h3><strong>题目：最大子数组和</strong></h3>\n<h4><strong>描述：</strong></h4>\n<p>给定一个整数数组 <code>nums</code>，请找出一个具有最大和的连续子数组（子数组最少包含一个元素），并返回其最大和。</p>\n<hr>\n<h3><strong>示例：</strong></h3>\n<p><strong>示例 1:</strong></p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]</span></span>\n<span class="line"><span>输出: 6</span></span>\n<span class="line"><span>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:2.68,words:803},t:"最大子数组和",i:"pen-to-square",y:"a"}}],["/leetcode/%E6%95%B0%E7%BB%84/%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0.html",{loader:()=>s.e(6293).then(s.bind(s,8725)),meta:{d:16980192e5,l:"2023年10月23日",c:["后端"],g:["数组","leecode"],e:'\n<h3><strong>题目：缺失的第一个正数</strong></h3>\n<h4><strong>描述</strong></h4>\n<p>给定一个未排序的整数数组 <code>nums</code>，请找出其中没有出现的最小的正整数。</p>\n<p>要求：</p>\n<ul>\n<li>时间复杂度为 <code>O(n)</code>。</li>\n<li>只使用常数级别的额外空间。</li>\n</ul>\n<hr>\n<h3><strong>示例</strong></h3>\n<p><strong>示例 1:</strong></p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入: nums = [1,2,0]</span></span>\n<span class="line"><span>输出: 3</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:4.14,words:1242},t:"缺失的第一个正数",i:"pen-to-square",y:"a"}}],["/leetcode/%E6%95%B0%E7%BB%84/%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84.html",{loader:()=>s.e(3955).then(s.bind(s,5327)),meta:{d:16928352e5,l:"2023年8月24日",c:["后端"],g:["数组","leecode"],e:'\n<h3><strong>题目：轮转数组</strong></h3>\n<h4><strong>描述：</strong></h4>\n<p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p>\n<hr>\n<h3><strong>示例：</strong></h3>\n<p><strong>示例 1:</strong></p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入: nums = [1,2,3,4,5,6,7], k = 3</span></span>\n<span class="line"><span>输出: [5,6,7,1,2,3,4]</span></span>\n<span class="line"><span>解释:</span></span>\n<span class="line"><span>向右轮转 1 步: [7,1,2,3,4,5,6]</span></span>\n<span class="line"><span>向右轮转 2 步: [6,7,1,2,3,4,5]</span></span>\n<span class="line"><span>向右轮转 3 步: [5,6,7,1,2,3,4]</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:2.82,words:846},t:"轮转数组",i:"pen-to-square",y:"a"}}],["/leetcode/%E6%95%B0%E7%BB%84/%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF.html",{loader:()=>s.e(6076).then(s.bind(s,8255)),meta:{d:16822944e5,l:"2023年4月24日",c:["后端"],g:["数组","leecode"],e:"\n<h3><strong>题目：除自身以外数组的乘积</strong></h3>\n<h4><strong>描述</strong></h4>\n<p>给定一个整数数组 <code>nums</code>，返回数组 <code>answer</code>，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积。</p>\n<p><strong>要求：</strong></p>\n<ul>\n<li>不允许使用除法。</li>\n<li>时间复杂度要求为 <code>O(n)</code>。</li>\n</ul>",r:{minutes:2.74,words:822},t:"除自身以外数组的乘积",i:"pen-to-square",y:"a"}}],["/leetcode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html",{loader:()=>s.e(2841).then(s.bind(s,376)),meta:{d:1672704e6,l:"2023年1月3日",c:["后端"],g:["滑动窗口","leecode"],e:'\n<h3><strong>题目：找到字符串中所有字母异位词</strong></h3>\n<p><strong>描述：</strong></p>\n<p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到字符串 <code>s</code> 中所有 <code>p</code> 的异位词的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>\n<hr>\n<h3><strong>示例：</strong></h3>\n<p><strong>示例 1:</strong></p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入: s = "cbaebabacd", p = "abc"</span></span>\n<span class="line"><span>输出: [0, 6]</span></span>\n<span class="line"><span>解释:</span></span>\n<span class="line"><span>起始索引 0 的子串是 "cba"，是 "abc" 的异位词。</span></span>\n<span class="line"><span>起始索引 6 的子串是 "bac"，是 "abc" 的异位词。</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:2.93,words:880},t:"找到字符串中所有字母异位词",i:"pen-to-square",y:"a"}}],["/leetcode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.html",{loader:()=>s.e(4338).then(s.bind(s,2469)),meta:{d:16844544e5,l:"2023年5月19日",c:["后端"],g:["滑动窗口","leecode"],e:'\n<h3><strong>题目：无重复字符的最长子串</strong></h3>\n<p><strong>描述：</strong></p>\n<p>给定一个字符串 <code>s</code>，找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>\n<hr>\n<h3><strong>示例：</strong></h3>\n<p><strong>示例 1:</strong></p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入: s = "abcabcbb"</span></span>\n<span class="line"><span>输出: 3</span></span>\n<span class="line"><span>解释: 最长子串是 "abc"，其长度为 3。</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:2.76,words:829},t:"无重复字符的最长子串",i:"pen-to-square",y:"a"}}],["/leetcode/%E7%9F%A9%E9%98%B5/%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5.html",{loader:()=>s.e(7527).then(s.bind(s,1026)),meta:{d:16969824e5,l:"2023年10月11日",c:["后端"],g:["矩阵","leecode"],e:'\n<h4>题目描述</h4>\n<p>编写一个高效的算法来搜索 <code>m x n</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code>。</p>\n<p>矩阵具有以下特性：</p>\n<ol>\n<li>每行的元素从左到右升序排列。</li>\n<li>每列的元素从上到下升序排列。</li>\n</ol>\n<hr>\n<h4>示例</h4>\n<p><strong>示例 1：</strong></p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入：matrix = [</span></span>\n<span class="line"><span>  [1, 4, 7, 11, 15],</span></span>\n<span class="line"><span>  [2, 5, 8, 12, 19],</span></span>\n<span class="line"><span>  [3, 6, 9, 16, 22],</span></span>\n<span class="line"><span>  [10, 13, 14, 17, 24],</span></span>\n<span class="line"><span>  [18, 21, 23, 26, 30]</span></span>\n<span class="line"><span>], target = 5</span></span>\n<span class="line"><span>输出：true</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:2.9,words:869},t:"搜索二维矩阵",i:"pen-to-square",y:"a"}}],["/leetcode/%E7%9F%A9%E9%98%B5/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F.html",{loader:()=>s.e(3159).then(s.bind(s,891)),meta:{d:16657056e5,l:"2022年10月14日",c:["后端"],g:["矩阵","leecode"],e:'\n<h4>题目描述</h4>\n<p>给定一个 <code>n × n</code> 的二维矩阵 <code>matrix</code> 表示一个图像。将图像顺时针旋转 90 度，要求：</p>\n<ul>\n<li>必须<strong>原地</strong>旋转，即直接修改输入的二维矩阵。</li>\n<li>不允许使用额外的矩阵辅助旋转。</li>\n</ul>\n<h4>示例</h4>\n<p><strong>示例 1：</strong></p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入：</span></span>\n<span class="line"><span>matrix = [</span></span>\n<span class="line"><span>  [1, 2, 3],</span></span>\n<span class="line"><span>  [4, 5, 6],</span></span>\n<span class="line"><span>  [7, 8, 9]</span></span>\n<span class="line"><span>]</span></span>\n<span class="line"><span>输出：</span></span>\n<span class="line"><span>[</span></span>\n<span class="line"><span>  [7, 4, 1],</span></span>\n<span class="line"><span>  [8, 5, 2],</span></span>\n<span class="line"><span>  [9, 6, 3]</span></span>\n<span class="line"><span>]</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:2.67,words:802},t:"旋转图像",i:"pen-to-square",y:"a"}}],["/leetcode/%E7%9F%A9%E9%98%B5/%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6.html",{loader:()=>s.e(8641).then(s.bind(s,755)),meta:{d:16698528e5,l:"2022年12月1日",c:["后端"],g:["矩阵","leecode"],e:'\n<h3><strong>题目：矩阵置零</strong></h3>\n<h4><strong>描述</strong></h4>\n<p>给定一个 <code>m x n</code> 的矩阵，如果其中一个元素为 <code>0</code>，则将其所在行和列的所有元素都设置为 <code>0</code>。要求使用 <strong>原地算法</strong>，即在不使用额外空间的情况下完成操作。</p>\n<hr>\n<h3><strong>示例</strong></h3>\n<p><strong>示例 1</strong>：</p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]</span></span>\n<span class="line"><span>输出：[[1,0,1],[0,0,0],[1,0,1]]</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:3.55,words:1064},t:"矩阵置零",i:"pen-to-square",y:"a"}}],["/leetcode/%E7%9F%A9%E9%98%B5/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5.html",{loader:()=>s.e(5126).then(s.bind(s,1187)),meta:{d:1689552e6,l:"2023年7月17日",c:["后端"],g:["矩阵","leecode"],e:'\n<hr>\n<h3>题目：54. 螺旋矩阵</h3>\n<h4>题目描述</h4>\n<p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code>，请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p>\n<h4>示例</h4>\n<p><strong>示例 1:</strong></p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入: matrix = [</span></span>\n<span class="line"><span>  [1, 2, 3],</span></span>\n<span class="line"><span>  [4, 5, 6],</span></span>\n<span class="line"><span>  [7, 8, 9]</span></span>\n<span class="line"><span>]</span></span>\n<span class="line"><span>输出: [1, 2, 3, 6, 9, 8, 7, 4, 5]</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:4.2,words:1260},t:"螺旋矩阵",i:"pen-to-square",y:"a"}}],["/leetcode/%E9%93%BE%E8%A1%A8/%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.html",{loader:()=>s.e(4045).then(s.bind(s,7893)),meta:{d:16687296e5,l:"2022年11月18日",c:["后端"],g:["链表","快慢指针","leecode"],e:'\n<h3>合并两个有序链表</h3>\n<h4>题目描述</h4>\n<p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>\n<p><strong>示例 1：</strong></p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入：l1 = [1,2,4], l2 = [1,3,4]</span></span>\n<span class="line"><span>输出：[1,1,2,3,4,4]</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:3.34,words:1003},t:"合并两个有序链表",i:"pen-to-square",y:"a"}}],["/leetcode/%E9%93%BE%E8%A1%A8/%E4%BF%A9%E6%95%B0%E7%9B%B8%E5%8A%A0.html",{loader:()=>s.e(6606).then(s.bind(s,5632)),meta:{d:1681776e6,l:"2023年4月18日",c:["算法"],g:["链表","leetcode"],e:'\n<h3><strong>题目：两数相加</strong></h3>\n<h4><strong>描述</strong></h4>\n<p>给定两个非空链表，表示两个非负整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。</p>\n<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>\n<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>\n<hr>\n<h3><strong>示例</strong></h3>\n<p><strong>示例 1:</strong></p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入: l1 = [2,4,3], l2 = [5,6,4]</span></span>\n<span class="line"><span>输出: [7,0,8]</span></span>\n<span class="line"><span>解释: 342 + 465 = 807</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:3.99,words:1198},t:"两数相加",i:"pen-to-square",y:"a"}}],["/leetcode/%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html",{loader:()=>s.e(5396).then(s.bind(s,8759)),meta:{d:1685232e6,l:"2023年5月28日",c:["后端"],g:["链表","leecode"],e:'\n<h4>题目描述</h4>\n<p>给定单链表的头节点 <code>head</code>，请你反转链表，并返回反转后的链表。</p>\n<hr>\n<h4>示例</h4>\n<p><strong>示例 1</strong>：</p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入：head = [1, 2, 3, 4, 5]</span></span>\n<span class="line"><span>输出：[5, 4, 3, 2, 1]</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:3.29,words:988},t:"反转链表",i:"pen-to-square",y:"a"}}],["/leetcode/%E9%93%BE%E8%A1%A8/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8.html",{loader:()=>s.e(2018).then(s.bind(s,4798)),meta:{d:16936128e5,l:"2023年9月2日",c:["后端"],g:["链表","快慢指针","leecode"],e:'\n<h4>题目描述</h4>\n<p>给定一个单链表的头节点 <code>head</code>，判断该链表是否为<strong>回文链表</strong>。如果是，返回 <code>true</code>；否则，返回 <code>false</code>。</p>\n<hr>\n<h4>示例</h4>\n<p><strong>示例 1</strong>：</p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入：head = [1,2,2,1]</span></span>\n<span class="line"><span>输出：true</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:3.06,words:918},t:"回文链表",i:"pen-to-square",y:"a"}}],["/leetcode/%E9%93%BE%E8%A1%A8/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II.html",{loader:()=>s.e(9164).then(s.bind(s,939)),meta:{d:16881696e5,l:"2023年7月1日",c:["后端"],g:["链表","快慢指针","leecode"],e:"\n<h4>题目描述</h4>\n<p>给定一个链表的头节点 <code>head</code>，返回链表开始入环的第一个节点。如果链表无环，则返回 <code>null</code>。</p>\n<ul>\n<li><strong>链表中有环</strong>：链表的某个节点的 <code>next</code> 指针指向了链表中某个先前的节点，形成一个环。即从某个节点开始，你可以一直沿着 <code>next</code> 指针循环回到该节点。</li>\n<li><strong>链表中没有环</strong>：链表的每个节点的 <code>next</code> 指针指向 <code>null</code>，并且遍历完链表后会到达末尾。</li>\n</ul>",r:{minutes:4.28,words:1283},t:"环形链表 II",i:"pen-to-square",y:"a"}}],["/leetcode/%E9%93%BE%E8%A1%A8/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.html",{loader:()=>s.e(6376).then(s.bind(s,8919)),meta:{d:16911936e5,l:"2023年8月5日",c:["后端"],g:["链表","快慢指针","leecode"],e:"\n<h4>题目描述</h4>\n<p>给定一个链表的头节点 <code>head</code>，判断链表中是否存在环。</p>\n<ul>\n<li><strong>链表中有环</strong>：链表的某个节点的 <code>next</code> 指针指向了链表中某个先前的节点，形成一个环。即从某个节点开始，你可以一直沿着 <code>next</code> 指针循环回到该节点。</li>\n<li><strong>链表中没有环</strong>：链表的每个节点的 <code>next</code> 指针指向 <code>null</code>，并且遍历完链表后会到达末尾。</li>\n</ul>\n<p>你需要实现一个高效的算法，判断链表是否有环。</p>",r:{minutes:3.39,words:1016},t:"环形链表",i:"pen-to-square",y:"a"}}],["/leetcode/%E9%93%BE%E8%A1%A8/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.html",{loader:()=>s.e(2253).then(s.bind(s,3701)),meta:{d:16637184e5,l:"2022年9月21日",c:["后端"],g:["链表","leecode"],e:'\n<h4>题目描述</h4>\n<p>给定两个单链表的头节点 <code>headA</code> 和 <code>headB</code>，找出并返回两个链表相交的起始节点。如果两个链表不存在相交节点，则返回 <code>null</code>。</p>\n<p><strong>注意</strong>：</p>\n<ul>\n<li>整个链表结构中不存在环。</li>\n<li>返回的节点需要是两个链表实际相交的节点，而不是一个新的节点。</li>\n<li>不可以破坏链表的原始结构。</li>\n</ul>\n<hr>\n<h4>示例</h4>\n<p><strong>示例 1</strong>：</p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入：headA = [4,1,8,4,5], headB = [5,0,1,8,4,5]</span></span>\n<span class="line"><span>输出：Intersected at \'8\'</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:3.31,words:992},t:"相交链表",i:"pen-to-square",y:"a"}}],["/tech/%E5%9C%BA%E6%99%AF/Rpc.html",{loader:()=>s.e(2812).then(s.bind(s,5069)),meta:{d:17349984e5,l:"2024年12月24日",c:["后端"],g:["Java","面试","场景"],e:"\n<hr>\n<h2>前言：什么是 RPC？为啥要它？</h2>\n<p>先打个比方：</p>\n<p>你去餐厅点菜，你只负责“点”，不关心厨师怎么做、厨房在哪。你说：“我要一份麻辣烫”，然后等着吃。</p>\n<p><strong>RPC（Remote Procedure Call，远程过程调用）</strong> 就像这样：</p>\n<ul>\n<li>你是客户端</li>\n<li>餐厅是服务器</li>\n<li>厨房逻辑封装好了</li>\n<li>你用“本地方式”发出“远程请求”，结果返回到你手里</li>\n</ul>\n<p><strong>一句话理解：</strong></p>\n<blockquote>\n<p>RPC 让你像调用本地函数一样，去调用另一台服务器上的服务。</p>\n</blockquote>",r:{minutes:3.19,words:956},t:"如果让你设计一个 RPC 框架，你该怎么做？",i:"pen-to-square",y:"a"}}],["/tech/%E5%9C%BA%E6%99%AF/mq.html",{loader:()=>s.e(4261).then(s.bind(s,1978)),meta:{d:17264448e5,l:"2024年9月16日",c:["后端"],g:["Java","面试","场景"],e:"\n<hr>\n<h2>什么是消息队列？一句话说清楚</h2>\n<blockquote>\n<p>消息队列（Message Queue）是一个系统中用来传话的“快递中转站”。</p>\n</blockquote>\n<p>它负责把“消息”从发送方（生产者）<strong>传递</strong>到接收方（消费者）——\n而且还能：</p>\n<ul>\n<li>保证不会丢件（消息不丢失）* 顺序到达（支持顺序消费）* 如果收件人晚点来也没关系（异步解耦）### 举个例子：</li>\n</ul>\n<p>淘宝订单支付成功后，会发生很多事：</p>\n<ul>\n<li>给你发短信</li>\n<li>给仓库发发货请求</li>\n<li>给商家发账单</li>\n</ul>",r:{minutes:4.01,words:1203},t:"从零开始教你设计一个消息队列系统（MQ）：通俗易懂、细节到位",i:"pen-to-square",y:"a"}}],["/tech/%E5%9C%BA%E6%99%AF/mq%E6%B6%88%E8%B4%B9%E6%96%B9%E5%BC%8F.html",{loader:()=>s.e(7454).then(s.bind(s,3994)),meta:{d:17436384e5,l:"2025年4月3日",c:["后端"],g:["Java","面试","场景"],e:"\n<hr>\n<h2>为什么这个问题很重要？</h2>\n<p>面试官问这个问题，其实是想考你两个核心能力：</p>\n<ol>\n<li><strong>对消息消费流程是否熟悉？</strong></li>\n<li><strong>能否根据业务需求选择合适的方式？</strong></li>\n</ol>\n<p>但很多人回答都是一句话：“Kafka 用拉，RabbitMQ 用推”，没有深入细节、没有类比解释、没有系统思考。</p>\n<p>本篇我们从 0 到 1，搞清楚以下问题：</p>\n<ul>\n<li>推模式 vs 拉模式到底差在哪？</li>\n<li>各有什么优缺点？</li>\n<li>哪些场景适合推？哪些适合拉？</li>\n<li>Kafka、RabbitMQ 等主流 MQ 怎么选的？</li>\n<li>实战中如何设计出一个可控的消费流程？</li>\n</ul>",r:{minutes:3.7,words:1109},t:"消息队列到底该用推（Push）还是拉（Pull）？一文吃透两种模式！",i:"pen-to-square",y:"a"}}],["/tech/%E5%9C%BA%E6%99%AF/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%95%E4%BE%8B.html",{loader:()=>s.e(4555).then(s.bind(s,4356)),meta:{d:17170272e5,l:"2024年5月30日",c:["后端"],g:["Java","面试","场景"],e:'\n<hr>\n<h2>1. 什么是单例？什么是分布式单例？</h2>\n<p>我们先说说**单例模式（Singleton）**是干嘛的。</p>\n<p>在 Java 里，我们希望一个类的对象<strong>只存在一份实例</strong>，整个程序都共享这个对象，这就是单例模式。你可能写过这样的代码：</p>\n<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> Singleton</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> final</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> Singleton</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75"> INSTANCE </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> Singleton</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> Singleton</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> getInstance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF"> INSTANCE;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">}</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:3.41,words:1023},t:"分布式单例对象怎么实现？彻底讲透，别再一知半解！",i:"pen-to-square",y:"a"}}],["/tech/%E5%9C%BA%E6%99%AF/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html",{loader:()=>s.e(8672).then(s.bind(s,6914)),meta:{d:17220384e5,l:"2024年7月27日",c:["后端"],g:["Java","面试","场景"],e:"\n<hr>\n<h2>背景介绍：为什么需要分布式锁？</h2>\n<p>先看常见场景：</p>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>问题</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>多服务部署的库存扣减</td>\n<td>多个服务节点并发更新库存，导致库存为负</td>\n</tr>\n<tr>\n<td>定时任务</td>\n<td>多个实例执行重复任务</td>\n</tr>\n<tr>\n<td>防止重复提交</td>\n<td>用户疯狂点击按钮，创建多个重复订单</td>\n</tr>\n</tbody>\n</table>\n<p><strong>传统锁（如 ReentrantLock）仅在当前进程内有效，无法跨 JVM 实例、跨服务节点协调</strong>。</p>",r:{minutes:2.95,words:885},t:"Redis 分布式锁实现原理 + Java 完整实现教程",i:"pen-to-square",y:"a"}}],["/tech/%E5%9C%BA%E6%99%AF/%E5%B9%B6%E5%8F%91%E6%B5%81%E7%BB%9F%E8%AE%A1.html",{loader:()=>s.e(3375).then(s.bind(s,9629)),meta:{d:17130528e5,l:"2024年4月14日",c:["后端"],g:["Java","面试","场景"],e:"\n<hr>\n<h2>背景场景（题目）</h2>\n<p>有一张数据库表，包含以下字段：</p>\n<ul>\n<li><code>id</code>：主键，自增</li>\n<li><code>start_time</code>：业务开始时间</li>\n<li><code>end_time</code>：业务结束时间</li>\n</ul>\n<p>表中一共有 <strong>5000 万条记录</strong>，每条记录代表一个“时间段”（例如一个用户会话、一次任务执行等）。</p>\n<blockquote>\n<p>问题是：<strong>在所有时间点中，哪一秒并发量最大？最多有多少条记录在该秒同时处于活动状态？</strong></p>\n</blockquote>",r:{minutes:3.1,words:931},t:"如何用扫描线算法统计最大并发数？以 5000 万条记录为例讲清楚！",i:"pen-to-square",y:"a"}}],["/tech/%E5%9C%BA%E6%99%AF/%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8Cdfa%E7%AE%97%E6%B3%95%E8%84%B1%E6%95%8F.html",{loader:()=>s.e(3346).then(s.bind(s,623)),meta:{d:17083872e5,l:"2024年2月20日",c:["后端"],g:["Java","面试","场景"],e:"\n<h2>1️⃣ 背景介绍</h2>\n<p>在一次支付宝的营销活动中，由于 <strong>运营配置错误</strong>，原本应该给用户发放「满减」优惠券，却被误配成了「8 折优惠」，导致大规模资金损失。</p>\n<p><strong>核心问题</strong>：运营人员在配置营销模板时，把优惠额度和优惠类型都写错了。</p>\n<p>这类事故提醒我们：<strong>系统要有能力帮助用户防止低级错误，避免人为疏忽带来巨大损失。</strong></p>\n<hr>\n<h2>2️⃣ 事故的本质原因</h2>\n<p>根据公开信息，事故原因是：</p>\n<ul>\n<li>运维或运营人员配置营销活动模板时出错。</li>\n<li>系统缺乏多重防护机制，错误配置直接生效。</li>\n<li>缺乏实时监控与熔断机制。</li>\n</ul>",r:{minutes:3.21,words:963},t:"支付宝 8 折优惠事故背后的技术反思：如何设计系统避免低级失误？",i:"pen-to-square",y:"a"}}],["/tech/%E5%9C%BA%E6%99%AF/%E7%9F%AD%E9%93%BE%E6%8E%A5.html",{loader:()=>s.e(4077).then(s.bind(s,3929)),meta:{d:17397504e5,l:"2025年2月17日",c:["后端"],g:["Java","面试","场景"],e:'\n<hr>\n<h2>背景：什么是短链接？为什么要设计它？</h2>\n<p>在实际开发中，我们经常会遇到一些<strong>超长 URL</strong>，例如：</p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>https://www.jd.com/special/activity/2024-07-13/ads/campaign?id=987654321&amp;user=abc</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div></div></div>',r:{minutes:3.48,words:1044},t:"短链接系统全流程设计详解：从原理到落地，一篇看懂！",i:"pen-to-square",y:"a"}}],["/tech/%E5%9C%BA%E6%99%AF/%E7%A7%92%E6%9D%80.html",{loader:()=>s.e(9017).then(s.bind(s,4257)),meta:{d:17304192e5,l:"2024年11月1日",c:["后端"],g:["Java","面试","场景"],e:"\n<hr>\n<h2>一句话介绍什么是秒杀？</h2>\n<blockquote>\n<p>秒杀（flash sale）= 瞬间有大量用户同时请求一个极少的库存资源（比如抢 10 台手机，100 万人点进来）</p>\n</blockquote>\n<p>它是对系统<strong>并发能力、限流策略、数据一致性、业务稳定性</strong>的全方位考验。</p>\n<hr>\n<h2>秒杀系统的核心难点（你必须解决）</h2>\n<ol>\n<li><strong>瞬时流量暴涨</strong>：百万请求在 1 秒内涌入</li>\n<li><strong>防止超卖</strong>：库存不能卖超</li>\n<li><strong>用户去重</strong>：一个用户只能买一次</li>\n<li><strong>系统抗压</strong>：要保护核心系统不被打挂</li>\n<li><strong>兜底方案</strong>：即使秒杀失败，也能优雅提示</li>\n</ol>",r:{minutes:3.49,words:1046},t:"从零教你如何设计一个高并发“秒杀”系统？",i:"pen-to-square",y:"a"}}],["/tech/%E6%95%99%E7%A8%8B/Java%20Static%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90.html",{loader:()=>s.e(9433).then(s.bind(s,9526)),meta:{a:"Steven267",d:16985376e5,l:"2023年10月29日",c:["技术教程"],g:["Java","static","面向对象","Java基础","内存管理"],o:!0,e:"\n<h2>Static</h2>\n<h3>作用</h3>\n<p>Static是Java的一个关键字，用于声明静态成员或者方法。Static的作用是为类的成员（字段和方法）分配一个共享的内存空间，而不是为每一个类的对象分别进行内存分配。（Ps：但我们多个对象想操控同一个变量时，就可以在类中定义一个静态变量）</p>\n<h3>知识补充</h3>\n<h4><strong>类加载 (Class Loading)</strong>:</h4>\n<ul>\n<li>类加载是指将类的字节码文件加载到 JVM 中的过程。</li>\n<li>当你使用类时，JVM 需要将类加载到内存中，以便可以创建对象和执行类的方法。</li>\n<li>类加载发生在对象创建之前，因为在创建对象之前，必须首先加载类。</li>\n</ul>",r:{minutes:5.65,words:1695},t:"Java Static关键字完全解析",y:"a"}}],["/tech/%E6%95%99%E7%A8%8B/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%20-%20PATH%E4%B8%8ECLASSPATH.html",{loader:()=>s.e(1318).then(s.bind(s,8159)),meta:{a:"Steven267",d:16985376e5,l:"2023年10月29日",c:["技术教程"],g:["Java","环境配置","Java基础","开发环境","Maven"],o:!0,e:"\n<p>在Java中，<code>PATH</code> 和 <code>CLASSPATH</code> 是两个不同的环境变量，它们用于配置 Java 运行时和编译时的类路径和可执行程序路径。</p>\n<h2>PATH</h2>\n<p><code>PATH</code> 环境变量是用来指定我们操作系统在查找可执行程序时候应该搜索的目录，当你使用命令行在任意路径下Java程序**（javac、java、jar等命令）**或者其他可执行的文件时候，操作系统会在PATH中列出的目录中查找可执行文件。</p>\n<h3>PATH的主要作用</h3>\n<ol>\n<li><strong>系统级别配置</strong>：让系统能够在任何位置找到Java相关命令</li>\n<li><strong>全局访问</strong>：无需输入完整路径即可执行Java工具</li>\n<li><strong>开发便利性</strong>：提供便捷的命令行开发体验</li>\n</ol>",r:{minutes:7.94,words:2381},t:"Java环境变量配置详解 - PATH与CLASSPATH",y:"a"}}],["/tech/%E6%95%99%E7%A8%8B/Java%E7%A8%8B%E5%BA%8F%E8%BD%ACexe%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B.html",{loader:()=>s.e(393).then(s.bind(s,7249)),meta:{a:"Steven267",d:1728432e6,l:"2024年10月9日",c:["技术教程"],g:["Java","exe4j","inno setup","程序打包","部署"],u:99,o:!0,e:'\n<h2>前言</h2>\n<p>公司给了一个需求，要求写一个工具，来实现rsa非对称加密鉴权，来实现不通过网络传输加密过程，来鉴权修改密码，用户通过在本地使用我的工具搭配私钥和新密码，可以实现生成签名，加密完成以后，需要封装成程序，方便以后用户部署本地使用。</p>\n<p>RSA鉴权加密修改密码，仓库已上传github：<a href="https://github.com/Steven-267/rsa" target="_blank" rel="noopener noreferrer">https://github.com/Steven-267/rsa</a></p>\n<h2>Java实现exe</h2>',r:{minutes:4.32,words:1295},t:"MacOS实现 java程序转换成exe(程序附带rsa非对称加密鉴权修改密码github仓库)",y:"a"}}],["/404.html",{loader:()=>s.e(7490).then(s.bind(s,4510)),meta:{t:""}}],["/tech/",{loader:()=>s.e(8287).then(s.bind(s,8177)),meta:{t:"Tech"}}],["/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/",{loader:()=>s.e(2032).then(s.bind(s,5648)),meta:{t:"双指针"}}],["/leetcode/",{loader:()=>s.e(1252).then(s.bind(s,9719)),meta:{t:"Leetcode"}}],["/leetcode/%E5%93%88%E5%B8%8C/",{loader:()=>s.e(1205).then(s.bind(s,4622)),meta:{t:"哈希"}}],["/leetcode/%E5%AD%90%E4%B8%B2/",{loader:()=>s.e(6995).then(s.bind(s,2889)),meta:{t:"子串"}}],["/leetcode/%E6%95%B0%E7%BB%84/",{loader:()=>s.e(869).then(s.bind(s,3512)),meta:{t:"数组"}}],["/leetcode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/",{loader:()=>s.e(7862).then(s.bind(s,5062)),meta:{t:"滑动窗口"}}],["/leetcode/%E7%9F%A9%E9%98%B5/",{loader:()=>s.e(6507).then(s.bind(s,4992)),meta:{t:"矩阵"}}],["/leetcode/%E9%93%BE%E8%A1%A8/",{loader:()=>s.e(887).then(s.bind(s,2319)),meta:{t:"链表"}}],["/tech/%E5%9C%BA%E6%99%AF/",{loader:()=>s.e(4123).then(s.bind(s,8263)),meta:{t:"场景"}}],["/tech/%E6%95%99%E7%A8%8B/",{loader:()=>s.e(3e3).then(s.bind(s,3824)),meta:{t:"教程"}}],["/category/",{loader:()=>s.e(3583).then(s.bind(s,905)),meta:{t:"分类",I:!1}}],["/category/%E6%80%9D%E8%80%83/",{loader:()=>s.e(6724).then(s.bind(s,4626)),meta:{t:"思考 分类",I:!1}}],["/category/%E5%90%8E%E7%AB%AF/",{loader:()=>s.e(4887).then(s.bind(s,4564)),meta:{t:"后端 分类",I:!1}}],["/category/%E7%AE%97%E6%B3%95/",{loader:()=>s.e(9544).then(s.bind(s,7102)),meta:{t:"算法 分类",I:!1}}],["/category/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/",{loader:()=>s.e(9041).then(s.bind(s,3932)),meta:{t:"技术教程 分类",I:!1}}],["/tag/",{loader:()=>s.e(1797).then(s.bind(s,4103)),meta:{t:"标签",I:!1}}],["/tag/%E6%80%9D%E8%80%83/",{loader:()=>s.e(8582).then(s.bind(s,5300)),meta:{t:"标签: 思考",I:!1}}],["/tag/%E8%81%8C%E5%9C%BA%E6%84%9F%E6%82%9F/",{loader:()=>s.e(9194).then(s.bind(s,1859)),meta:{t:"标签: 职场感悟",I:!1}}],["/tag/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/",{loader:()=>s.e(3172).then(s.bind(s,9951)),meta:{t:"标签: 技术人生",I:!1}}],["/tag/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E7%94%9F%E6%B4%BB/",{loader:()=>s.e(4525).then(s.bind(s,2620)),meta:{t:"标签: 工作与生活",I:!1}}],["/tag/%E5%8F%8C%E6%8C%87%E9%92%88/",{loader:()=>s.e(2433).then(s.bind(s,6783)),meta:{t:"标签: 双指针",I:!1}}],["/tag/leecode/",{loader:()=>s.e(4717).then(s.bind(s,7972)),meta:{t:"标签: leecode",I:!1}}],["/tag/%E5%93%88%E5%B8%8C/",{loader:()=>s.e(6470).then(s.bind(s,4213)),meta:{t:"标签: 哈希",I:!1}}],["/tag/%E5%AD%90%E4%B8%B2/",{loader:()=>s.e(8972).then(s.bind(s,2001)),meta:{t:"标签: 子串",I:!1}}],["/tag/%E5%89%8D%E7%BC%80%E5%92%8C/",{loader:()=>s.e(3897).then(s.bind(s,5171)),meta:{t:"标签: 前缀和",I:!1}}],["/tag/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/",{loader:()=>s.e(8993).then(s.bind(s,338)),meta:{t:"标签: 滑动窗口",I:!1}}],["/tag/%E6%95%B0%E7%BB%84/",{loader:()=>s.e(5494).then(s.bind(s,1984)),meta:{t:"标签: 数组",I:!1}}],["/tag/%E7%9F%A9%E9%98%B5/",{loader:()=>s.e(776).then(s.bind(s,6824)),meta:{t:"标签: 矩阵",I:!1}}],["/tag/%E9%93%BE%E8%A1%A8/",{loader:()=>s.e(6068).then(s.bind(s,388)),meta:{t:"标签: 链表",I:!1}}],["/tag/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/",{loader:()=>s.e(4852).then(s.bind(s,4100)),meta:{t:"标签: 快慢指针",I:!1}}],["/tag/leetcode/",{loader:()=>s.e(6701).then(s.bind(s,4996)),meta:{t:"标签: leetcode",I:!1}}],["/tag/java/",{loader:()=>s.e(250).then(s.bind(s,1320)),meta:{t:"标签: Java",I:!1}}],["/tag/%E9%9D%A2%E8%AF%95/",{loader:()=>s.e(243).then(s.bind(s,5803)),meta:{t:"标签: 面试",I:!1}}],["/tag/%E5%9C%BA%E6%99%AF/",{loader:()=>s.e(7393).then(s.bind(s,8357)),meta:{t:"标签: 场景",I:!1}}],["/tag/static/",{loader:()=>s.e(7132).then(s.bind(s,3003)),meta:{t:"标签: static",I:!1}}],["/tag/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/",{loader:()=>s.e(3349).then(s.bind(s,4101)),meta:{t:"标签: 面向对象",I:!1}}],["/tag/java%E5%9F%BA%E7%A1%80/",{loader:()=>s.e(2488).then(s.bind(s,2193)),meta:{t:"标签: Java基础",I:!1}}],["/tag/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/",{loader:()=>s.e(2516).then(s.bind(s,9875)),meta:{t:"标签: 内存管理",I:!1}}],["/tag/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/",{loader:()=>s.e(5435).then(s.bind(s,3927)),meta:{t:"标签: 环境配置",I:!1}}],["/tag/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/",{loader:()=>s.e(8047).then(s.bind(s,2075)),meta:{t:"标签: 开发环境",I:!1}}],["/tag/maven/",{loader:()=>s.e(9405).then(s.bind(s,7077)),meta:{t:"标签: Maven",I:!1}}],["/tag/exe4j/",{loader:()=>s.e(7688).then(s.bind(s,6462)),meta:{t:"标签: exe4j",I:!1}}],["/tag/inno-setup/",{loader:()=>s.e(1414).then(s.bind(s,1381)),meta:{t:"标签: inno setup",I:!1}}],["/tag/%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/",{loader:()=>s.e(5216).then(s.bind(s,1459)),meta:{t:"标签: 程序打包",I:!1}}],["/tag/%E9%83%A8%E7%BD%B2/",{loader:()=>s.e(4420).then(s.bind(s,9577)),meta:{t:"标签: 部署",I:!1}}],["/article/",{loader:()=>s.e(7511).then(s.bind(s,9574)),meta:{t:"文章",I:!1}}],["/star/",{loader:()=>s.e(7199).then(s.bind(s,3639)),meta:{t:"星标",I:!1}}],["/timeline/",{loader:()=>s.e(5464).then(s.bind(s,3931)),meta:{t:"时间轴",I:!1}}]])},8761:(e,n,s)=>{s.d(n,{U:()=>a});const a=JSON.parse('{"base":"/My_Blog/","lang":"zh-CN","title":"Steven267的技术博客","description":"记录技术学习和面试准备的博客","head":[["link",{"rel":"preload","href":"/My_Blog/assets/images/backgrounds/sunrise-mountain.png","as":"image"}],["link",{"rel":"dns-prefetch","href":"//fonts.googleapis.com"}],["meta",{"name":"format-detection","content":"telephone=no"}]],"locales":{}}')},6653:(e,n,s)=>{s.d(n,{K:()=>a});const a=JSON.parse('{"encrypt":{"config":{"/demo/encrypt.html":["$2a$10$MI4NK.3uK.53r6fx3r9eeeSnhQvlSbx92CTtrGzUs3jO15j2v2quK"]}},"author":{"name":"Steven267","url":"steven267-avatar.jpg"},"logo":"steven267-avatar.jpg","logoDark":"steven267-avatar.jpg","repo":"Steven-267/My_Blog","repoLabel":"GitHub","docsDir":"src","darkmode":"switch","fullscreen":true,"pageInfo":["Author","Original","Date","Category","Tag","ReadingTime"],"footer":"Code with Passion, Debug with Patience. 用热情编码，用耐心调试。","displayFooter":true,"blog":{"description":"Innovation distinguishes between a leader and a follower.","avatar":"steven267-avatar.jpg","articlePerPage":10,"medias":{"GitHub":"https://github.com/Steven-267"}},"locales":{"/":{"lang":"zh-CN","navbarLocales":{"langName":"简体中文","selectLangAriaLabel":"选择语言"},"metaLocales":{"author":"作者","date":"写作日期","origin":"原创","views":"访问量","category":"分类","tag":"标签","readingTime":"阅读时间","words":"字数","toc":"此页内容","prev":"上一页","next":"下一页","lastUpdated":"上次编辑于","contributors":"贡献者","editLink":"在 GitHub 上编辑此页","print":"打印"},"blogLocales":{"article":"文章","articleList":"文章列表","category":"分类","tag":"标签","timeline":"时间轴","timelineTitle":"昨日不在","all":"全部","intro":"个人介绍","star":"星标","empty":"$text 为空"},"paginationLocales":{"prev":"上一页","next":"下一页","navigate":"跳转到","action":"前往","errorText":"请输入 1 到 $page 之前的页码！"},"outlookLocales":{"themeColor":"主题色","darkmode":"外观","fullscreen":"全屏"},"encryptLocales":{"iconLabel":"文章已加密","placeholder":"输入密码","remember":"记住密码","errorHint":"请输入正确的密码"},"routeLocales":{"skipToContent":"跳至主要內容","notFoundTitle":"页面不存在","notFoundMsg":["这里什么也没有","我们是怎么来到这儿的？","这 是 四 零 四 !","看起来你访问了一个失效的链接"],"back":"返回上一页","home":"带我回家","openInNewWindow":"Open in new window"},"navbar":["/",{"text":"数据结构与算法","icon":"fas fa-sitemap","link":"/leetcode/"},{"text":"技术提升","icon":"fas fa-folder-open","link":"/tech/"}],"sidebar":{"/leetcode/":[{"text":"哈希","icon":" fas fa-project-diagram","prefix":"哈希/","children":"structure","collapsible":true,"expanded":true},{"text":"双指针","icon":" fas fa-project-diagram","prefix":"双指针/","children":"structure","collapsible":true,"expanded":true},{"text":"滑动窗口","icon":" fas fa-project-diagram","prefix":"滑动窗口/","children":"structure","collapsible":true,"expanded":true},{"text":"子串","icon":" fas fa-project-diagram","prefix":"子串/","children":"structure","collapsible":true,"expanded":true},{"text":"数组","icon":" fas fa-project-diagram","prefix":"数组/","children":"structure","collapsible":true,"expanded":true},{"text":"矩阵","icon":" fas fa-project-diagram","prefix":"矩阵/","children":"structure","collapsible":true,"expanded":true},{"text":"链表","icon":" fas fa-project-diagram","prefix":"链表/","children":"structure","collapsible":true,"expanded":true}],"/tech/":[{"text":"技术感悟","icon":"fas fa-lightbulb","children":[{"text":"技术之外，我们该思考些什么？","link":"技术之外，我们该思考些什么？","icon":"fas fa-star"}],"collapsible":true,"expanded":true},{"text":"技术教程","icon":"fas fa-book","prefix":"教程/","children":"structure","collapsible":true,"expanded":true},{"text":"技术场景","icon":"fas fa-sitemap","prefix":"场景/","children":"structure","collapsible":true,"expanded":true}],"/":[""]}}}}')},8123:(e,n,s)=>{s.d(n,{v:()=>a});const a={"/leetcode/哈希/":["俩数之和","最长连续序列","字母异位词分组"],"/leetcode/双指针/":["三数之和","接雨水","盛最多水的容器","移动零"],"/leetcode/滑动窗口/":["找到字符串中所有字母异位词","无重复字符的最长子串"],"/leetcode/子串/":["最小覆盖子串","和为 K 的子数组","滑动窗口最大值"],"/leetcode/数组/":["最大子数组和","合并区间","缺失的第一个正数","轮转数组","除自身以外数组的乘积"],"/leetcode/矩阵/":["搜索二维矩阵","旋转图像","矩阵置零","螺旋矩阵"],"/leetcode/链表/":["俩数相加","反转链表"," 合并两个有序链表","回文链表","环形链表","环形链表 II","相交链表"],"/tech/教程/":["Java Static关键字完全解析","Java环境变量配置详解 - PATH与CLASSPATH","Java程序转exe可执行文件完整教程"],"/tech/场景/":["分布式锁","mq","秒杀","分布式单例","并发流统计","Rpc","拦截器和dfa算法脱敏","mq消费方式","短链接"]}},2878:(e,n,s)=>{s.d(n,{P:()=>a});const a={GitHub:'<svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024"><circle cx="512" cy="512" r="512" fill="#171515"/><path fill="#fff" d="M509.423 146.442c-200.317 0-362.756 162.42-362.756 362.8 0 160.266 103.936 296.24 248.109 344.217 18.139 3.327 24.76-7.872 24.76-17.486 0-8.613-.313-31.427-.49-61.702-100.912 21.923-122.205-48.63-122.205-48.63-16.495-41.91-40.28-53.067-40.28-53.067-32.937-22.51 2.492-22.053 2.492-22.053 36.407 2.566 55.568 37.386 55.568 37.386 32.362 55.438 84.907 39.43 105.58 30.143 3.296-23.444 12.667-39.43 23.032-48.498-80.557-9.156-165.246-40.28-165.246-179.297 0-39.604 14.135-71.988 37.342-97.348-3.731-9.178-16.18-46.063 3.556-96.009 0 0 30.46-9.754 99.76 37.19 28.937-8.048 59.97-12.071 90.823-12.211 30.807.14 61.843 4.165 90.822 12.21 69.26-46.944 99.663-37.189 99.663-37.189 19.792 49.946 7.34 86.831 3.61 96.01 23.25 25.359 37.29 57.742 37.29 97.347 0 139.366-84.82 170.033-165.637 179.013 13.026 11.2 24.628 33.342 24.628 67.182 0 48.498-.445 87.627-.445 99.521 0 9.702 6.535 20.988 24.945 17.444 144.03-48.067 247.881-183.95 247.881-344.175 0-200.378-162.442-362.798-362.802-362.798z"/></svg>'}}},e=>{e.O(0,[101,9932],(()=>e(e.s=8731))),e.O()}]);