---
icon: pen-to-square
date: 2024-11-25
category:
- 后端
tag:
- 矩阵
- leecode
---
# 旋转图像


#### 题目描述

给定一个 `n × n` 的二维矩阵 `matrix` 表示一个图像。将图像顺时针旋转 90 度，要求：
- 必须**原地**旋转，即直接修改输入的二维矩阵。
- 不允许使用额外的矩阵辅助旋转。

#### 示例

**示例 1：**

```
输入：
matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
]
输出：
[
  [7, 4, 1],
  [8, 5, 2],
  [9, 6, 3]
]
```

**示例 2：**

```
输入：
matrix = [
  [5, 1, 9, 11],
  [2, 4, 8, 10],
  [13, 3, 6, 7],
  [15, 14, 12, 16]
]
输出：
[
  [15, 13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7, 10, 11]
]
```

---

### 解题思路

要在原地实现顺时针旋转 90 度，我们可以分两步完成：

#### 1. **矩阵转置**
- **什么是转置？** 把矩阵的行变为列，例如：
  ```
  原始矩阵：
  1  2  3
  4  5  6
  7  8  9

  转置后：
  1  4  7
  2  5  8
  3  6  9
  ```

- **如何实现？** 遍历矩阵上三角部分（或者下三角部分），交换矩阵中对应的元素：`matrix[i][j]` 和 `matrix[j][i]`。

#### 2. **水平翻转**
- **什么是水平翻转？** 把矩阵的每一行左右翻转，例如：
  ```
  转置后矩阵：
  1  4  7
  2  5  8
  3  6  9

  水平翻转后：
  7  4  1
  8  5  2
  9  6  3
  ```

- **如何实现？** 遍历矩阵的每一行，将每行的第 `i` 列和倒数第 `i` 列的元素交换。

这两步操作可以在不借助额外的矩阵的情况下完成，满足题目要求。

---

### 代码实现

```java
public class RotateImage {
    public void rotate(int[][] matrix) {
        int n = matrix.length;

        // 1. 矩阵转置
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }

        // 2. 水平翻转
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n / 2; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[i][n - 1 - j];
                matrix[i][n - 1 - j] = temp;
            }
        }
    }

    public static void main(String[] args) {
        RotateImage solution = new RotateImage();

        int[][] matrix1 = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        solution.rotate(matrix1);
        for (int[] row : matrix1) {
            System.out.println(java.util.Arrays.toString(row));
        }
        // 输出:
        // [7, 4, 1]
        // [8, 5, 2]
        // [9, 6, 3]

        int[][] matrix2 = {
            {5, 1, 9, 11},
            {2, 4, 8, 10},
            {13, 3, 6, 7},
            {15, 14, 12, 16}
        };
        solution.rotate(matrix2);
        for (int[] row : matrix2) {
            System.out.println(java.util.Arrays.toString(row));
        }
        // 输出:
        // [15, 13, 2, 5]
        // [14, 3, 4, 1]
        // [12, 6, 8, 9]
        // [16, 7, 10, 11]
    }
}
```

---

### 为什么选择这种方法？

1. **直接操作矩阵，无需额外空间**：
    - 转置操作只需要交换矩阵元素，无需额外矩阵存储数据。
    - 水平翻转操作同样只在原矩阵中完成。

2. **时间复杂度最优**：
    - **矩阵转置**：每个元素只访问一次，因此时间复杂度为 \( O(n^2) \)。
    - **水平翻转**：每个元素也只访问一次，时间复杂度为 \( O(n^2) \)。
    - 总时间复杂度为 \( O(n^2) \)。

3. **符合顺时针旋转的数学规律**：
    - 转置让行变列。
    - 水平翻转让列的位置反转，最终完成顺时针旋转。

---

### 注意事项

1. **边界条件**：
    - 如果矩阵为空或者只有一个元素（`n = 1`），直接返回即可。

2. **原地修改**：
    - 确保不借助任何额外存储空间。

3. **矩阵大小**：
    - 题目保证是 `n × n` 矩阵，无需考虑矩阵非方阵的情况。

---



