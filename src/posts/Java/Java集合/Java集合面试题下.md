---
icon: pen-to-square
date: 2024-11-14
category:
- 后端
tag:
- Java
- 集合
- 后端开发技巧
---
# Java集合面试题下


### **1. `HashMap` 和 `Hashtable` 的区别：**
1. **线程安全性**：
    - **`Hashtable`** 是线程安全的，它的所有方法都被 `synchronized` 修饰。由于对整个数据结构加锁，性能会有一定的影响，尤其在多线程环境下竞争较激烈时，可能导致较低的效率。
    - **`HashMap`** 是非线程安全的，但性能较高。为了保证线程安全，可以使用 `ConcurrentHashMap` 代替。

2. **对 `null` 值的支持**：
    - **`Hashtable`** 不允许 `null` 键和值。若尝试插入 `null`，会抛出 `NullPointerException`。
    - **`HashMap`** 允许一个 `null` 键和多个 `null` 值。

3. **初始化容量和扩容规则**：
    - **`Hashtable`** 默认初始容量为 11，负载因子为 0.75，扩容时将容量变为原来的 2n + 1。
    - **`HashMap`** 默认初始容量为 16，负载因子为 0.75，扩容时将容量翻倍。`HashMap` 使用 2 的幂次方来扩展容量，这是为了提高性能，避免哈希冲突。

4. **继承体系**：
    - **`Hashtable`** 继承自 `Dictionary` 类，`Dictionary` 是 JDK 1.0 引入的，已被弃用。
    - **`HashMap`** 继承自 `AbstractMap`，并实现了 `Map` 接口。

5. **迭代器**：
    - **`Hashtable`** 使用 `Enumeration` 进行迭代，而 `Enumeration` 并不支持 fail-fast 机制，即修改集合时不会抛出异常。
    - **`HashMap`** 使用 `Iterator`，它是 fail-fast 的，如果在迭代过程中修改集合，将抛出 `ConcurrentModificationException`。

6. **底层实现**：
    - **`Hashtable`** 底层使用的是数组加链表来存储数据，但没有进行链表转红黑树的优化。
    - **`HashMap`** 在 JDK 1.8 以后对哈希冲突的处理做了优化，当链表长度超过阈值时（默认为 8），会将链表转换为红黑树以提高查询性能。

### **2. `HashMap` 和 `HashSet` 的区别：**
1. **数据结构**：
    - **`HashSet`** 是一个基于 `HashMap` 实现的 Set 接口，底层是使用 `HashMap` 来存储数据。它不允许重复的元素，因此底层会利用 `HashMap` 来判断元素是否已存在。
    - **`HashMap`** 是一个基于键值对的映射，存储数据时会关联一个 `key` 和一个 `value`。

2. **重复元素**：
    - **`HashSet`** 不允许存储重复的元素。如果插入一个已经存在的元素，它会忽略该元素。
    - **`HashMap`** 允许 `key` 的重复，但不允许 `key` 和 `value` 配对的重复（即相同的 `key` 不会存在多个相同的 `value`）。

3. **接口和功能**：
    - **`HashSet`** 只实现了 `Set` 接口，提供元素的无序存储，不保证插入顺序。
    - **`HashMap`** 实现了 `Map` 接口，提供键值对存储，支持对键的查找和访问。

### **3. `HashMap` 和 `TreeMap` 的区别：**
1. **排序**：
    - **`TreeMap`** 是有序的，它根据键的自然顺序或构造时提供的比较器对元素进行排序。
    - **`HashMap`** 是无序的，它的元素没有特定的顺序。

2. **性能**：
    - **`TreeMap`** 的查找、插入和删除操作的时间复杂度为 O(log n)，这是因为它底层使用红黑树实现。
    - **`HashMap`** 的查找、插入和删除操作的时间复杂度为 O(1)，但在极端情况下（如大量哈希冲突）可能会退化为 O(n)。

3. **适用场景**：
    - 如果需要按照键的排序存储数据，可以使用 **`TreeMap`**。
    - 如果不关心排序，只需要快速存储和查找数据，可以使用 **`HashMap`**。

### **4. `HashSet` 如何检查重复元素：**
- **`HashSet`** 通过调用其底层 `HashMap` 的 `containsKey` 方法来检查元素是否已存在。如果已经存在，则不插入新元素。底层通过 `hashCode()` 和 `equals()` 方法来比较元素。

### **5. `HashMap` 的底层实现**：
- **`HashMap`** 底层使用数组和链表（或红黑树）来实现存储。每个数组元素是一个链表（或树的根节点），哈希冲突发生时，元素将以链表形式存储。链表过长时（超过阈值），会转换为红黑树来提高查找效率。

### **6. `HashMap` 线程不安全的原因**：
- `HashMap` 不是线程安全的，因为它没有同步机制来保证并发访问时的正确性。当多个线程同时对 `HashMap` 进行读写操作时，可能会出现数据不一致或死循环等问题。因此，在多线程环境中，应使用 `ConcurrentHashMap` 或手动同步访问 `HashMap`。


