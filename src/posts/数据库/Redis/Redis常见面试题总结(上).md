---
icon: pen-to-square
date: 2024-11-23
category:
- 后端
tag:
- Redis
- 数据库
---
# Redis常见面试题总结(上)


---

## **1. Redis 基础**

### **1.1 什么是 Redis？**
Redis 是一个开源的 **高性能分布式内存数据库**，支持多种数据结构，用于缓存、消息队列、分布式锁、实时统计等。

**回答方式**：Redis 是内存型数据库，它的核心特性是高性能和多数据结构支持。

---

### **1.2 Redis 为什么这么快？**
1. **数据存储在内存**：
    - 读写操作在内存中完成，访问速度快。
2. **单线程模型**：
    - 避免了多线程的上下文切换和锁竞争。
3. **高效数据结构**：
    - 使用优化后的跳表、哈希表等数据结构。
4. **I/O 多路复用**：
    - 基于 `epoll` 的非阻塞 I/O 模型，同时处理大量请求。

**示例**：
```plaintext
传统数据库：磁盘读取速度慢，且受 I/O 阻塞影响。
Redis：所有数据在内存中，读写可以达到百万级 QPS。
```

---

### **1.3 Redis 和 Memcached 的区别**

**共同点**：
- 都是内存型数据库，主要用于缓存。
- 都支持高性能读写。

**区别**：

| 特性               | Redis                                | Memcached                           |
|--------------------|--------------------------------------|-------------------------------------|
| **数据类型**        | 多种（String、Hash、List、Set 等）   | 仅支持 String                      |
| **持久化**          | 支持（RDB 和 AOF）                  | 不支持                             |
| **线程模型**        | 单线程为主（6.0+ 支持部分多线程）     | 多线程                             |
| **内存管理**        | LRU 淘汰策略，适合复杂场景           | 使用 Slab 分配，适合简单缓存       |
| **功能丰富性**      | 支持分布式锁、消息队列等高级功能      | 功能相对简单                       |

**回答方式**：Redis 和 Memcached 都是优秀的缓存解决方案，但 Redis 更适合多样化场景。

---

### **1.4 为什么要用 Redis？**
1. **性能高**：
    - QPS 达到 10 万级别。
2. **功能丰富**：
    - 支持复杂数据结构。
3. **生态完善**：
    - 支持分布式锁、延时任务、排行榜等高级功能。
4. **应用场景多样**：
    - 缓存、会话存储、实时数据分析。

---

### **1.5 常见的缓存策略**
1. **Cache Aside（旁路缓存）**：
    - **读流程**：先查缓存，未命中则查数据库并回写缓存。
    - **写流程**：先更新数据库，再删除缓存。

   **示例**：
   ```plaintext
   用户请求商品详情：
   1. 查 Redis 缓存（命中则返回）。
   2. 未命中：查 MySQL 数据库，将结果写入 Redis。
   ```

2. **Write Through（写穿缓存）**：
    - 数据写入时同时更新缓存和数据库。

3. **Write Back（写回缓存）**：
    - 数据先写入缓存，后台异步更新数据库。

---

## **2. Redis 应用**

### **2.1 Redis 除了缓存，还能做什么？**
1. **分布式锁**：使用 `SETNX` 和 `EX`。
2. **延时任务**：基于 `ZSET` 存储任务和时间戳。
3. **消息队列**：用 `List` 实现生产者-消费者模型。
4. **实时统计**：使用 `HyperLogLog` 或 `Bitmap` 统计活跃用户、UV。

---

### **2.2 如何实现分布式锁？**

使用 `SETNX` 实现分布式锁：
```bash
SETNX lock_key 1 EX 10  # 尝试获取锁，设置过期时间为 10 秒
```

**解锁操作**：
1. 检查当前锁是否为自己持有（`GET`）。
2. 确认后删除锁（`DEL`）。

**面试官关注点**：
- **优点**：原子操作，简单高效。
- **难点**：锁过期续约，防止死锁。

---

### **2.3 Redis 可以做消息队列么？**

- **使用 List 实现**：
    - **生产者**：
      ```bash
      LPUSH queue_key "message"
      ```
    - **消费者**：
      ```bash
      RPOP queue_key
      ```

**优点**：易实现、高性能。

**缺点**：无法保证严格的消息顺序（解决方法：用 Stream）。

---

### **2.4 如何基于 Redis 实现延时任务？**

使用 **ZSET** 存储任务和时间戳：
1. 添加任务：
   ```bash
   ZADD delay_tasks 1680000000 "task1"
   ```
2. 获取到期任务：
   ```bash
   ZRANGEBYSCORE delay_tasks 0 CURRENT_TIMESTAMP
   ```

**场景**：
- 订单支付超时提醒。
- 定时清理无效数据。

---

## **3. Redis 数据类型**

### **3.1 数据类型及场景**

| 数据类型   | **应用场景**                                    |
|------------|------------------------------------------------|
| String     | 缓存单值，计数器，分布式锁                    |
| Hash       | 存储对象数据，减少内存占用                    |
| List       | 消息队列、链表存储                            |
| Set        | 标签筛选、抽奖                                |
| ZSet       | 排行榜、延时任务                             |

---

### **3.2 使用 Redis 实现排行榜**

使用 **ZSET** 存储用户和分数：
1. **添加分数**：
   ```bash
   ZADD leaderboard 100 "Alice"
   ZADD leaderboard 200 "Bob"
   ```
2. **获取排行榜**：
   ```bash
   ZREVRANGE leaderboard 0 9 WITHSCORES
   ```

---

## **4. Redis 持久化机制**

### **4.1 Redis 的持久化方式**
1. **RDB（快照）**：
    - 定期将内存快照保存到磁盘。
    - **优点**：占用资源少。
    - **缺点**：数据可能丢失。

2. **AOF（日志）**：
    - 记录每个写操作。
    - **优点**：更可靠。
    - **缺点**：磁盘 I/O 多。

**面试官喜欢的总结**：
- **高性能场景**：只用 RDB。
- **高可靠性场景**：同时开启 RDB 和 AOF。

---

## **5. Redis 线程模型**

### **5.1 Redis 单线程模型**
Redis 使用单线程处理请求，避免了锁竞争，提高并发性能。

**回答方式**：Redis 是单线程，但依赖高效的事件循环模型（如 `epoll`）。

---

### **5.2 为什么引入多线程？**
Redis 6.0 后支持多线程，用于处理网络 I/O 和数据压缩，但核心逻辑仍是单线程。

---

## **6. Redis 内存管理**

### **6.1 Redis 如何判断数据过期？**
1. **被动删除**：访问键时检查是否过期。
2. **定期删除**：每隔一段时间随机抽取部分键检查。

---

### **6.2 Redis 的内存淘汰策略**
1. **volatile-lru**：淘汰设置过期时间的键中最近最少使用的。
2. **allkeys-lru**：淘汰所有键中最近最少使用的。
3. **noeviction**：禁止淘汰，写入失败。

---

### **6.3 面试官喜欢的总结**
- **核心问题**：如何管理内存，避免 OOM（内存溢出）。
- **优化建议**：
    - 设置合理的过期时间。
    - 使用 LRU 淘汰策略。

---

## **总结**

1. **Redis 基础**：高性能的内存数据库，支持多种数据结构。
2. **Redis 应用**：分布式锁、消息队列、排行榜、延时任务等。
3. **数据类型与场景**：不同类型对应不同应用，善用特性。
4. **持久化与线程模型**：理解 RDB、AOF 的优缺点，掌握单线程优势。
5. **内存管理**：过期策略和淘汰策略是面试高频问题。

